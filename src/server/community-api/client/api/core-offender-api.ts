/* tslint:disable */
/* eslint-disable */
/**
 * Community API Documentation
 * <h2>REST service for accessing community probation information</h2><p>This service provides endpoints for accessing data primary sourced from National Delius about people that are of interest to HM Probation Service.</p><p>There is cross-over with the <b>prison-api</b> though suspects on remand will not be surfaced by this API unless that have previously been on probation.</p><div>This service is secured by <b>OAuth2</b> with tokens supplied by HMPPS Auth. Most read-only endpoints require the <b>ROLE_COMMUNITY</b> to access, but check each endpoint where this differs.<p>This service can be accessed in a number environments. For each environment a different set of OAuth2 credentials from HMPPS Auth are required</p><ul><li>Development: <b>https://community-api.dev.probation.service.justice.gov.uk</b></li><li>Test: <b>https://community-api.test.probation.service.justice.gov.uk</b></li><li>Pre-production: <b>https://community-api.pre-prod.delius.probation.hmpps.dsd.io</b></li><li>Production: <b>https://community-api.probation.service.justice.gov.uk</b></li></ul><div>
 *
 * The version of the OpenAPI document: 2021-05-21.4548.b3fe43e
 * Contact: dps-hmpps@digital.justice.gov.uk
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AccessLimitation } from '../model';
// @ts-ignore
import { CommunityOrPrisonOffenderManager } from '../model';
// @ts-ignore
import { Contact } from '../model';
// @ts-ignore
import { Conviction } from '../model';
// @ts-ignore
import { CreatePrisonOffenderManager } from '../model';
// @ts-ignore
import { ErrorResponse } from '../model';
// @ts-ignore
import { Nsi } from '../model';
// @ts-ignore
import { NsiWrapper } from '../model';
// @ts-ignore
import { OffenderAssessments } from '../model';
// @ts-ignore
import { OffenderDetail } from '../model';
// @ts-ignore
import { OffenderDetailSummary } from '../model';
// @ts-ignore
import { OffenderIdentifiers } from '../model';
// @ts-ignore
import { OffenderLatestRecall } from '../model';
// @ts-ignore
import { PageOfPrimaryIdentifiers } from '../model';
// @ts-ignore
import { ProbationStatusDetail } from '../model';
// @ts-ignore
import { ResponsibleOfficer } from '../model';
// @ts-ignore
import { ResponsibleOfficerSwitch } from '../model';
// @ts-ignore
import { SentenceStatus } from '../model';
/**
 * CoreOffenderApi - axios parameter creator
 * @export
 */
export const CoreOffenderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Requires role ROLE_COMMUNITY_CUSTODY_UPDATE
         * @summary Allocates the prison offender manager for an offender in custody. This operation may also have a side affect of creating a Staff member if one matching the name does not already exist. An existing staff member can be used if the staff id is supplied.
         * @param {string} nomsNumber nomsNumber
         * @param {CreatePrisonOffenderManager} prisonOffenderManager prisonOffenderManager
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allocatePrisonOffenderManagerByNomsNumberUsingPUT: async (nomsNumber: string, prisonOffenderManager: CreatePrisonOffenderManager, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomsNumber' is not null or undefined
            assertParamExists('allocatePrisonOffenderManagerByNomsNumberUsingPUT', 'nomsNumber', nomsNumber)
            // verify required parameter 'prisonOffenderManager' is not null or undefined
            assertParamExists('allocatePrisonOffenderManagerByNomsNumberUsingPUT', 'prisonOffenderManager', prisonOffenderManager)
            const localVarPath = `/secure/offenders/nomsNumber/{nomsNumber}/prisonOffenderManager`
                .replace(`{${"nomsNumber"}}`, encodeURIComponent(String(nomsNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prisonOffenderManager, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reveals if the logged on user can access details about the supplied offender
         * @param {string} crn crn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUserAccessByCrnUsingGET: async (crn: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'crn' is not null or undefined
            assertParamExists('checkUserAccessByCrnUsingGET', 'crn', crn)
            const localVarPath = `/secure/offenders/crn/{crn}/userAccess`
                .replace(`{${"crn"}}`, encodeURIComponent(String(crn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires role ROLE_COMMUNITY_CUSTODY_UPDATE
         * @summary Deallocates the prison offender manager for an offender in custody. The POM is set back to its unallocated state
         * @param {string} nomsNumber nomsNumber
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deallocatePrisonOffenderManagerByNomsNumberUsingDELETE: async (nomsNumber: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomsNumber' is not null or undefined
            assertParamExists('deallocatePrisonOffenderManagerByNomsNumberUsingDELETE', 'nomsNumber', nomsNumber)
            const localVarPath = `/secure/offenders/nomsNumber/{nomsNumber}/prisonOffenderManager`
                .replace(`{${"nomsNumber"}}`, encodeURIComponent(String(nomsNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts a NOMIS offender nomsNumber in the format A9999AA
         * @summary Returns the current community and prison offender managers for an offender
         * @param {string} nomsNumber Nomis number for the offender
         * @param {boolean} [includeProbationAreaTeams] include teams on the ProbationArea records
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOffenderManagersForOffenderUsingGET: async (nomsNumber: string, includeProbationAreaTeams?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomsNumber' is not null or undefined
            assertParamExists('getAllOffenderManagersForOffenderUsingGET', 'nomsNumber', nomsNumber)
            const localVarPath = `/secure/offenders/nomsNumber/{nomsNumber}/allOffenderManagers`
                .replace(`{${"nomsNumber"}}`, encodeURIComponent(String(nomsNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeProbationAreaTeams !== undefined) {
                localVarQueryParameter['includeProbationAreaTeams'] = includeProbationAreaTeams;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts an offender CRN in the format A999999
         * @summary Returns the current community and prison offender managers for an offender
         * @param {string} crn CRN for the offender
         * @param {boolean} [includeProbationAreaTeams] include teams on the ProbationArea records
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOffenderManagersForOffenderbyCrnUsingGET: async (crn: string, includeProbationAreaTeams?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'crn' is not null or undefined
            assertParamExists('getAllOffenderManagersForOffenderbyCrnUsingGET', 'crn', crn)
            const localVarPath = `/secure/offenders/crn/{crn}/allOffenderManagers`
                .replace(`{${"crn"}}`, encodeURIComponent(String(crn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeProbationAreaTeams !== undefined) {
                localVarQueryParameter['includeProbationAreaTeams'] = includeProbationAreaTeams;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the assessments for a CRN
         * @param {string} crn CRN for the offender
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssessmentsByCrnUsingGET: async (crn: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'crn' is not null or undefined
            assertParamExists('getAssessmentsByCrnUsingGET', 'crn', crn)
            const localVarPath = `/secure/offenders/crn/{crn}/assessments`
                .replace(`{${"crn"}}`, encodeURIComponent(String(crn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the conviction (AKA Delius Event) for a conviction ID and a CRN
         * @param {number} convictionId ID for the conviction / event
         * @param {string} crn CRN for the offender
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConvictionForOffenderByCrnAndConvictionIdUsingGET: async (convictionId: number, crn: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'convictionId' is not null or undefined
            assertParamExists('getConvictionForOffenderByCrnAndConvictionIdUsingGET', 'convictionId', convictionId)
            // verify required parameter 'crn' is not null or undefined
            assertParamExists('getConvictionForOffenderByCrnAndConvictionIdUsingGET', 'crn', crn)
            const localVarPath = `/secure/offenders/crn/{crn}/convictions/{convictionId}`
                .replace(`{${"convictionId"}}`, encodeURIComponent(String(convictionId)))
                .replace(`{${"crn"}}`, encodeURIComponent(String(crn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the convictions (AKA Delius Event) for an offender
         * @param {string} crn CRN for the offender
         * @param {boolean} [activeOnly] retrieve only active convictions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConvictionsForOffenderByCrnUsingGET: async (crn: string, activeOnly?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'crn' is not null or undefined
            assertParamExists('getConvictionsForOffenderByCrnUsingGET', 'crn', crn)
            const localVarPath = `/secure/offenders/crn/{crn}/convictions`
                .replace(`{${"crn"}}`, encodeURIComponent(String(crn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (activeOnly !== undefined) {
                localVarQueryParameter['activeOnly'] = activeOnly;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the convictions (AKA Delius Event) for an offender
         * @param {string} nomsNumber Nomis number for the offender
         * @param {boolean} [activeOnly] retrieve only active convictions
         * @param {boolean} [failOnDuplicate] Should fail if multiple offenders found regardless of status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConvictionsForOffenderUsingGET: async (nomsNumber: string, activeOnly?: boolean, failOnDuplicate?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomsNumber' is not null or undefined
            assertParamExists('getConvictionsForOffenderUsingGET', 'nomsNumber', nomsNumber)
            const localVarPath = `/secure/offenders/nomsNumber/{nomsNumber}/convictions`
                .replace(`{${"nomsNumber"}}`, encodeURIComponent(String(nomsNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (activeOnly !== undefined) {
                localVarQueryParameter['activeOnly'] = activeOnly;
            }

            if (failOnDuplicate !== undefined) {
                localVarQueryParameter['failOnDuplicate'] = failOnDuplicate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts an offender CRN in the format A999999
         * @summary Returns the latest recall and release details for an offender
         * @param {string} crn CRN for the offender
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestRecallAndReleaseForOffenderByCrnUsingGET: async (crn: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'crn' is not null or undefined
            assertParamExists('getLatestRecallAndReleaseForOffenderByCrnUsingGET', 'crn', crn)
            const localVarPath = `/secure/offenders/crn/{crn}/release`
                .replace(`{${"crn"}}`, encodeURIComponent(String(crn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts a NOMIS offender nomsNumber in the format A9999AA
         * @summary Returns the latest recall and release details for an offender
         * @param {string} nomsNumber Nomis number for the offender
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestRecallAndReleaseForOffenderUsingGET: async (nomsNumber: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomsNumber' is not null or undefined
            assertParamExists('getLatestRecallAndReleaseForOffenderUsingGET', 'nomsNumber', nomsNumber)
            const localVarPath = `/secure/offenders/nomsNumber/{nomsNumber}/release`
                .replace(`{${"nomsNumber"}}`, encodeURIComponent(String(nomsNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return an NSI by crn, convictionId and nsiId
         * @param {number} convictionId ID for the conviction / event
         * @param {string} crn CRN for the offender
         * @param {number} nsiId ID for the nsi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNsiByNsiIdUsingGET: async (convictionId: number, crn: string, nsiId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'convictionId' is not null or undefined
            assertParamExists('getNsiByNsiIdUsingGET', 'convictionId', convictionId)
            // verify required parameter 'crn' is not null or undefined
            assertParamExists('getNsiByNsiIdUsingGET', 'crn', crn)
            // verify required parameter 'nsiId' is not null or undefined
            assertParamExists('getNsiByNsiIdUsingGET', 'nsiId', nsiId)
            const localVarPath = `/secure/offenders/crn/{crn}/convictions/{convictionId}/nsis/{nsiId}`
                .replace(`{${"convictionId"}}`, encodeURIComponent(String(convictionId)))
                .replace(`{${"crn"}}`, encodeURIComponent(String(crn)))
                .replace(`{${"nsiId"}}`, encodeURIComponent(String(nsiId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the NSIs for a conviction ID and a CRN, filtering by NSI codes
         * @param {number} convictionId ID for the conviction / event
         * @param {string} crn CRN for the offender
         * @param {Array<string>} nsiCodes list of NSI codes to constrain by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNsiForOffenderByCrnAndConvictionIdUsingGET: async (convictionId: number, crn: string, nsiCodes: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'convictionId' is not null or undefined
            assertParamExists('getNsiForOffenderByCrnAndConvictionIdUsingGET', 'convictionId', convictionId)
            // verify required parameter 'crn' is not null or undefined
            assertParamExists('getNsiForOffenderByCrnAndConvictionIdUsingGET', 'crn', crn)
            // verify required parameter 'nsiCodes' is not null or undefined
            assertParamExists('getNsiForOffenderByCrnAndConvictionIdUsingGET', 'nsiCodes', nsiCodes)
            const localVarPath = `/secure/offenders/crn/{crn}/convictions/{convictionId}/nsis`
                .replace(`{${"convictionId"}}`, encodeURIComponent(String(convictionId)))
                .replace(`{${"crn"}}`, encodeURIComponent(String(crn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nsiCodes) {
                localVarQueryParameter['nsiCodes'] = nsiCodes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return all the NSIs for the CRN, active convictions only, filtering by NSI codes
         * @param {string} crn CRN for the offender
         * @param {Array<string>} nsiCodes list of NSI codes to constrain by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNsisForOffenderByCrnAndActiveConvictionsUsingGET: async (crn: string, nsiCodes: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'crn' is not null or undefined
            assertParamExists('getNsisForOffenderByCrnAndActiveConvictionsUsingGET', 'crn', crn)
            // verify required parameter 'nsiCodes' is not null or undefined
            assertParamExists('getNsisForOffenderByCrnAndActiveConvictionsUsingGET', 'nsiCodes', nsiCodes)
            const localVarPath = `/secure/offenders/crn/{crn}/convictions/active/nsis`
                .replace(`{${"crn"}}`, encodeURIComponent(String(crn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nsiCodes) {
                localVarQueryParameter['nsiCodes'] = nsiCodes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the contact details for an offender
         * @param {Array<string>} contactTypes contactTypes
         * @param {string} from from
         * @param {string} nomsNumber Nomis number for the offender
         * @param {string} to to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffenderContactReportByNomsNumberUsingGET: async (contactTypes: Array<string>, from: string, nomsNumber: string, to: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactTypes' is not null or undefined
            assertParamExists('getOffenderContactReportByNomsNumberUsingGET', 'contactTypes', contactTypes)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getOffenderContactReportByNomsNumberUsingGET', 'from', from)
            // verify required parameter 'nomsNumber' is not null or undefined
            assertParamExists('getOffenderContactReportByNomsNumberUsingGET', 'nomsNumber', nomsNumber)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getOffenderContactReportByNomsNumberUsingGET', 'to', to)
            const localVarPath = `/secure/offenders/nomsNumber/{nomsNumber}/contacts`
                .replace(`{${"nomsNumber"}}`, encodeURIComponent(String(nomsNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contactTypes) {
                localVarQueryParameter['contactTypes'] = contactTypes;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the convictions (AKA Delius Event) for an offender that contain RAR
         * @param {string} crn CRN for the offender
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffenderConvictionsWithRarByCrnUsingGET: async (crn: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'crn' is not null or undefined
            assertParamExists('getOffenderConvictionsWithRarByCrnUsingGET', 'crn', crn)
            const localVarPath = `/secure/offenders/crn/{crn}/convictions-with-rar`
                .replace(`{${"crn"}}`, encodeURIComponent(String(crn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the full offender detail for the given crn
         * @param {string} crn crn
         * @param {boolean} [authenticated] 
         * @param {string} [authorities0Authority] 
         * @param {object} [credentials] 
         * @param {object} [details] 
         * @param {object} [principal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffenderDetailByCrnUsingGET: async (crn: string, authenticated?: boolean, authorities0Authority?: string, credentials?: object, details?: object, principal?: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'crn' is not null or undefined
            assertParamExists('getOffenderDetailByCrnUsingGET', 'crn', crn)
            const localVarPath = `/secure/offenders/crn/{crn}/all`
                .replace(`{${"crn"}}`, encodeURIComponent(String(crn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authenticated !== undefined) {
                localVarQueryParameter['authenticated'] = authenticated;
            }

            if (authorities0Authority !== undefined) {
                localVarQueryParameter['authorities[0].authority'] = authorities0Authority;
            }

            if (credentials !== undefined) {
                localVarQueryParameter['credentials'] = credentials;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (principal !== undefined) {
                localVarQueryParameter['principal'] = principal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the full offender detail for the given nomsNumber. If multiple offender found the active one will be returned
         * @param {string} nomsNumber Nomis number for the offender
         * @param {boolean} [failOnDuplicate] Should fail if multiple offenders found
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffenderDetailByNomsNumberUsingGET: async (nomsNumber: string, failOnDuplicate?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomsNumber' is not null or undefined
            assertParamExists('getOffenderDetailByNomsNumberUsingGET', 'nomsNumber', nomsNumber)
            const localVarPath = `/secure/offenders/nomsNumber/{nomsNumber}/all`
                .replace(`{${"nomsNumber"}}`, encodeURIComponent(String(nomsNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (failOnDuplicate !== undefined) {
                localVarQueryParameter['failOnDuplicate'] = failOnDuplicate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the details for an offender. If multiple offenders found the active one wll be returned
         * @param {string} nomsNumber Nomis number for the offender
         * @param {boolean} [failOnDuplicate] Should fail if multiple offenders found regardless of status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffenderDetailsUsingGET: async (nomsNumber: string, failOnDuplicate?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomsNumber' is not null or undefined
            assertParamExists('getOffenderDetailsUsingGET', 'nomsNumber', nomsNumber)
            const localVarPath = `/secure/offenders/nomsNumber/{nomsNumber}`
                .replace(`{${"nomsNumber"}}`, encodeURIComponent(String(nomsNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (failOnDuplicate !== undefined) {
                localVarQueryParameter['failOnDuplicate'] = failOnDuplicate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * requires ROLE_COMMUNITY
         * @summary Return the identifiers for an offender using the crn
         * @param {string} crn crn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffenderIdentifiersByCrnUsingGET: async (crn: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'crn' is not null or undefined
            assertParamExists('getOffenderIdentifiersByCrnUsingGET', 'crn', crn)
            const localVarPath = `/secure/offenders/crn/{crn}/identifiers`
                .replace(`{${"crn"}}`, encodeURIComponent(String(crn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * requires ROLE_COMMUNITY
         * @summary Return the identifiers for an offender using NOMS number
         * @param {string} nomsNumber nomsNumber
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffenderIdentifiersByNomsNumberUsingGET: async (nomsNumber: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomsNumber' is not null or undefined
            assertParamExists('getOffenderIdentifiersByNomsNumberUsingGET', 'nomsNumber', nomsNumber)
            const localVarPath = `/secure/offenders/nomsNumber/{nomsNumber}/identifiers`
                .replace(`{${"nomsNumber"}}`, encodeURIComponent(String(nomsNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * requires ROLE_COMMUNITY
         * @summary Return the identifiers for an offender using offenderId
         * @param {number} offenderId offenderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffenderIdentifiersByOffenderIdUsingGET: async (offenderId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'offenderId' is not null or undefined
            assertParamExists('getOffenderIdentifiersByOffenderIdUsingGET', 'offenderId', offenderId)
            const localVarPath = `/secure/offenders/offenderId/{offenderId}/identifiers`
                .replace(`{${"offenderId"}}`, encodeURIComponent(String(offenderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return pageable list of all offender identifiers that match the supplied filter
         * @param {string} [activeDate] Filter by offenders that were active on the supplied date. Advised not to use this in conjunction with includeActiveOnly since that will effectively return offenders active of this supplied date and current date which is typically not what is required.
         * @param {boolean} [includeActiveOnly] Filter by offenders that are active, i.e. offenders on a sentence that probation has an interest in.
         * @param {boolean} [includeDeleted] Include deleted offenders
         * @param {number} [offset] 
         * @param {number} [page] Results page you want to retrieve (0..N)
         * @param {boolean} [paged] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {number} [size] Number of records per page.
         * @param {string} [sort] Sort column and direction. Multiple sort params allowed.
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffenderIdsUsingGET: async (activeDate?: string, includeActiveOnly?: boolean, includeDeleted?: boolean, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/secure/offenders/primaryIdentifiers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (activeDate !== undefined) {
                localVarQueryParameter['activeDate'] = (activeDate as any instanceof Date) ?
                    (activeDate as any).toISOString().substr(0,10) :
                    activeDate;
            }

            if (includeActiveOnly !== undefined) {
                localVarQueryParameter['includeActiveOnly'] = includeActiveOnly;
            }

            if (includeDeleted !== undefined) {
                localVarQueryParameter['includeDeleted'] = includeDeleted;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (paged !== undefined) {
                localVarQueryParameter['paged'] = paged;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (sortSorted !== undefined) {
                localVarQueryParameter['sort.sorted'] = sortSorted;
            }

            if (sortUnsorted !== undefined) {
                localVarQueryParameter['sort.unsorted'] = sortUnsorted;
            }

            if (unpaged !== undefined) {
                localVarQueryParameter['unpaged'] = unpaged;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the probation status for the given crn
         * @param {string} crn crn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffenderProbationStatusByCrnUsingGET: async (crn: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'crn' is not null or undefined
            assertParamExists('getOffenderProbationStatusByCrnUsingGET', 'crn', crn)
            const localVarPath = `/secure/offenders/crn/{crn}/probationStatus`
                .replace(`{${"crn"}}`, encodeURIComponent(String(crn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the offender summary for the given crn
         * @param {string} crn crn
         * @param {boolean} [authenticated] 
         * @param {string} [authorities0Authority] 
         * @param {object} [credentials] 
         * @param {object} [details] 
         * @param {object} [principal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffenderSummaryByCrnUsingGET: async (crn: string, authenticated?: boolean, authorities0Authority?: string, credentials?: object, details?: object, principal?: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'crn' is not null or undefined
            assertParamExists('getOffenderSummaryByCrnUsingGET', 'crn', crn)
            const localVarPath = `/secure/offenders/crn/{crn}`
                .replace(`{${"crn"}}`, encodeURIComponent(String(crn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authenticated !== undefined) {
                localVarQueryParameter['authenticated'] = authenticated;
            }

            if (authorities0Authority !== undefined) {
                localVarQueryParameter['authorities[0].authority'] = authorities0Authority;
            }

            if (credentials !== undefined) {
                localVarQueryParameter['credentials'] = credentials;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (principal !== undefined) {
                localVarQueryParameter['principal'] = principal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts a NOMIS offender nomsNumber in the format A9999AA
         * @summary Return the responsible officer (RO) for an offender
         * @param {string} nomsNumber Nomis number for the offender
         * @param {boolean} [current] Current only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResponsibleOfficersForOffenderUsingGET: async (nomsNumber: string, current?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomsNumber' is not null or undefined
            assertParamExists('getResponsibleOfficersForOffenderUsingGET', 'nomsNumber', nomsNumber)
            const localVarPath = `/secure/offenders/nomsNumber/{nomsNumber}/responsibleOfficers`
                .replace(`{${"nomsNumber"}}`, encodeURIComponent(String(nomsNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (current !== undefined) {
                localVarQueryParameter['current'] = current;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return sentence and custodial status information by crn, convictionId.
         * @param {number} convictionId ID for the conviction / event
         * @param {string} crn CRN for the offender
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSentenceStatusByConvictionIdUsingGET: async (convictionId: number, crn: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'convictionId' is not null or undefined
            assertParamExists('getSentenceStatusByConvictionIdUsingGET', 'convictionId', convictionId)
            // verify required parameter 'crn' is not null or undefined
            assertParamExists('getSentenceStatusByConvictionIdUsingGET', 'crn', crn)
            const localVarPath = `/secure/offenders/crn/{crn}/convictions/{convictionId}/sentenceStatus`
                .replace(`{${"convictionId"}}`, encodeURIComponent(String(convictionId)))
                .replace(`{${"crn"}}`, encodeURIComponent(String(crn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires role ROLE_COMMUNITY_CUSTODY_UPDATE
         * @summary Sets the responsible officer for an offender to either the current prison offender manager to community offender manager. This will allow the responsible officer to be set to an unallocated offender manager
         * @param {string} nomsNumber nomsNumber
         * @param {ResponsibleOfficerSwitch} responsibleOfficerSwitch responsibleOfficerSwitch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        switchResponsibleOfficerUsingPUT: async (nomsNumber: string, responsibleOfficerSwitch: ResponsibleOfficerSwitch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomsNumber' is not null or undefined
            assertParamExists('switchResponsibleOfficerUsingPUT', 'nomsNumber', nomsNumber)
            // verify required parameter 'responsibleOfficerSwitch' is not null or undefined
            assertParamExists('switchResponsibleOfficerUsingPUT', 'responsibleOfficerSwitch', responsibleOfficerSwitch)
            const localVarPath = `/secure/offenders/nomsNumber/{nomsNumber}/responsibleOfficer/switch`
                .replace(`{${"nomsNumber"}}`, encodeURIComponent(String(nomsNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(responsibleOfficerSwitch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update offender tier. Requires ROLE_MANAGEMENT_TIER_UPDATE
         * @param {string} crn CRN for the offender
         * @param {'A0' | 'A1' | 'A2' | 'A3' | 'B0' | 'B1' | 'B2' | 'B3' | 'C0' | 'C1' | 'C2' | 'C3' | 'D0' | 'D1' | 'D2' | 'D3'} tier New tier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTierUsingPOST: async (crn: string, tier: 'A0' | 'A1' | 'A2' | 'A3' | 'B0' | 'B1' | 'B2' | 'B3' | 'C0' | 'C1' | 'C2' | 'C3' | 'D0' | 'D1' | 'D2' | 'D3', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'crn' is not null or undefined
            assertParamExists('updateTierUsingPOST', 'crn', crn)
            // verify required parameter 'tier' is not null or undefined
            assertParamExists('updateTierUsingPOST', 'tier', tier)
            const localVarPath = `/secure/offenders/crn/{crn}/tier/{tier}`
                .replace(`{${"crn"}}`, encodeURIComponent(String(crn)))
                .replace(`{${"tier"}}`, encodeURIComponent(String(tier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoreOffenderApi - functional programming interface
 * @export
 */
export const CoreOffenderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoreOffenderApiAxiosParamCreator(configuration)
    return {
        /**
         * Requires role ROLE_COMMUNITY_CUSTODY_UPDATE
         * @summary Allocates the prison offender manager for an offender in custody. This operation may also have a side affect of creating a Staff member if one matching the name does not already exist. An existing staff member can be used if the staff id is supplied.
         * @param {string} nomsNumber nomsNumber
         * @param {CreatePrisonOffenderManager} prisonOffenderManager prisonOffenderManager
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async allocatePrisonOffenderManagerByNomsNumberUsingPUT(nomsNumber: string, prisonOffenderManager: CreatePrisonOffenderManager, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommunityOrPrisonOffenderManager>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.allocatePrisonOffenderManagerByNomsNumberUsingPUT(nomsNumber, prisonOffenderManager, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reveals if the logged on user can access details about the supplied offender
         * @param {string} crn crn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkUserAccessByCrnUsingGET(crn: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessLimitation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkUserAccessByCrnUsingGET(crn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Requires role ROLE_COMMUNITY_CUSTODY_UPDATE
         * @summary Deallocates the prison offender manager for an offender in custody. The POM is set back to its unallocated state
         * @param {string} nomsNumber nomsNumber
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deallocatePrisonOffenderManagerByNomsNumberUsingDELETE(nomsNumber: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deallocatePrisonOffenderManagerByNomsNumberUsingDELETE(nomsNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accepts a NOMIS offender nomsNumber in the format A9999AA
         * @summary Returns the current community and prison offender managers for an offender
         * @param {string} nomsNumber Nomis number for the offender
         * @param {boolean} [includeProbationAreaTeams] include teams on the ProbationArea records
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllOffenderManagersForOffenderUsingGET(nomsNumber: string, includeProbationAreaTeams?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CommunityOrPrisonOffenderManager>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllOffenderManagersForOffenderUsingGET(nomsNumber, includeProbationAreaTeams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accepts an offender CRN in the format A999999
         * @summary Returns the current community and prison offender managers for an offender
         * @param {string} crn CRN for the offender
         * @param {boolean} [includeProbationAreaTeams] include teams on the ProbationArea records
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllOffenderManagersForOffenderbyCrnUsingGET(crn: string, includeProbationAreaTeams?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CommunityOrPrisonOffenderManager>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllOffenderManagersForOffenderbyCrnUsingGET(crn, includeProbationAreaTeams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return the assessments for a CRN
         * @param {string} crn CRN for the offender
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssessmentsByCrnUsingGET(crn: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OffenderAssessments>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssessmentsByCrnUsingGET(crn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return the conviction (AKA Delius Event) for a conviction ID and a CRN
         * @param {number} convictionId ID for the conviction / event
         * @param {string} crn CRN for the offender
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConvictionForOffenderByCrnAndConvictionIdUsingGET(convictionId: number, crn: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Conviction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConvictionForOffenderByCrnAndConvictionIdUsingGET(convictionId, crn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return the convictions (AKA Delius Event) for an offender
         * @param {string} crn CRN for the offender
         * @param {boolean} [activeOnly] retrieve only active convictions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConvictionsForOffenderByCrnUsingGET(crn: string, activeOnly?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Conviction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConvictionsForOffenderByCrnUsingGET(crn, activeOnly, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return the convictions (AKA Delius Event) for an offender
         * @param {string} nomsNumber Nomis number for the offender
         * @param {boolean} [activeOnly] retrieve only active convictions
         * @param {boolean} [failOnDuplicate] Should fail if multiple offenders found regardless of status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConvictionsForOffenderUsingGET(nomsNumber: string, activeOnly?: boolean, failOnDuplicate?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Conviction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConvictionsForOffenderUsingGET(nomsNumber, activeOnly, failOnDuplicate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accepts an offender CRN in the format A999999
         * @summary Returns the latest recall and release details for an offender
         * @param {string} crn CRN for the offender
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestRecallAndReleaseForOffenderByCrnUsingGET(crn: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OffenderLatestRecall>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestRecallAndReleaseForOffenderByCrnUsingGET(crn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accepts a NOMIS offender nomsNumber in the format A9999AA
         * @summary Returns the latest recall and release details for an offender
         * @param {string} nomsNumber Nomis number for the offender
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestRecallAndReleaseForOffenderUsingGET(nomsNumber: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OffenderLatestRecall>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestRecallAndReleaseForOffenderUsingGET(nomsNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return an NSI by crn, convictionId and nsiId
         * @param {number} convictionId ID for the conviction / event
         * @param {string} crn CRN for the offender
         * @param {number} nsiId ID for the nsi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNsiByNsiIdUsingGET(convictionId: number, crn: string, nsiId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Nsi>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNsiByNsiIdUsingGET(convictionId, crn, nsiId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return the NSIs for a conviction ID and a CRN, filtering by NSI codes
         * @param {number} convictionId ID for the conviction / event
         * @param {string} crn CRN for the offender
         * @param {Array<string>} nsiCodes list of NSI codes to constrain by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNsiForOffenderByCrnAndConvictionIdUsingGET(convictionId: number, crn: string, nsiCodes: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NsiWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNsiForOffenderByCrnAndConvictionIdUsingGET(convictionId, crn, nsiCodes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return all the NSIs for the CRN, active convictions only, filtering by NSI codes
         * @param {string} crn CRN for the offender
         * @param {Array<string>} nsiCodes list of NSI codes to constrain by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNsisForOffenderByCrnAndActiveConvictionsUsingGET(crn: string, nsiCodes: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NsiWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNsisForOffenderByCrnAndActiveConvictionsUsingGET(crn, nsiCodes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the contact details for an offender
         * @param {Array<string>} contactTypes contactTypes
         * @param {string} from from
         * @param {string} nomsNumber Nomis number for the offender
         * @param {string} to to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOffenderContactReportByNomsNumberUsingGET(contactTypes: Array<string>, from: string, nomsNumber: string, to: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Contact>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOffenderContactReportByNomsNumberUsingGET(contactTypes, from, nomsNumber, to, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return the convictions (AKA Delius Event) for an offender that contain RAR
         * @param {string} crn CRN for the offender
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOffenderConvictionsWithRarByCrnUsingGET(crn: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Conviction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOffenderConvictionsWithRarByCrnUsingGET(crn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the full offender detail for the given crn
         * @param {string} crn crn
         * @param {boolean} [authenticated] 
         * @param {string} [authorities0Authority] 
         * @param {object} [credentials] 
         * @param {object} [details] 
         * @param {object} [principal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOffenderDetailByCrnUsingGET(crn: string, authenticated?: boolean, authorities0Authority?: string, credentials?: object, details?: object, principal?: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OffenderDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOffenderDetailByCrnUsingGET(crn, authenticated, authorities0Authority, credentials, details, principal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the full offender detail for the given nomsNumber. If multiple offender found the active one will be returned
         * @param {string} nomsNumber Nomis number for the offender
         * @param {boolean} [failOnDuplicate] Should fail if multiple offenders found
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOffenderDetailByNomsNumberUsingGET(nomsNumber: string, failOnDuplicate?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OffenderDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOffenderDetailByNomsNumberUsingGET(nomsNumber, failOnDuplicate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return the details for an offender. If multiple offenders found the active one wll be returned
         * @param {string} nomsNumber Nomis number for the offender
         * @param {boolean} [failOnDuplicate] Should fail if multiple offenders found regardless of status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOffenderDetailsUsingGET(nomsNumber: string, failOnDuplicate?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OffenderDetailSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOffenderDetailsUsingGET(nomsNumber, failOnDuplicate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * requires ROLE_COMMUNITY
         * @summary Return the identifiers for an offender using the crn
         * @param {string} crn crn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOffenderIdentifiersByCrnUsingGET(crn: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OffenderIdentifiers>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOffenderIdentifiersByCrnUsingGET(crn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * requires ROLE_COMMUNITY
         * @summary Return the identifiers for an offender using NOMS number
         * @param {string} nomsNumber nomsNumber
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOffenderIdentifiersByNomsNumberUsingGET(nomsNumber: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OffenderIdentifiers>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOffenderIdentifiersByNomsNumberUsingGET(nomsNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * requires ROLE_COMMUNITY
         * @summary Return the identifiers for an offender using offenderId
         * @param {number} offenderId offenderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOffenderIdentifiersByOffenderIdUsingGET(offenderId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OffenderIdentifiers>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOffenderIdentifiersByOffenderIdUsingGET(offenderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return pageable list of all offender identifiers that match the supplied filter
         * @param {string} [activeDate] Filter by offenders that were active on the supplied date. Advised not to use this in conjunction with includeActiveOnly since that will effectively return offenders active of this supplied date and current date which is typically not what is required.
         * @param {boolean} [includeActiveOnly] Filter by offenders that are active, i.e. offenders on a sentence that probation has an interest in.
         * @param {boolean} [includeDeleted] Include deleted offenders
         * @param {number} [offset] 
         * @param {number} [page] Results page you want to retrieve (0..N)
         * @param {boolean} [paged] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {number} [size] Number of records per page.
         * @param {string} [sort] Sort column and direction. Multiple sort params allowed.
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOffenderIdsUsingGET(activeDate?: string, includeActiveOnly?: boolean, includeDeleted?: boolean, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageOfPrimaryIdentifiers>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOffenderIdsUsingGET(activeDate, includeActiveOnly, includeDeleted, offset, page, paged, pageNumber, pageSize, size, sort, sortSorted, sortUnsorted, unpaged, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the probation status for the given crn
         * @param {string} crn crn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOffenderProbationStatusByCrnUsingGET(crn: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProbationStatusDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOffenderProbationStatusByCrnUsingGET(crn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the offender summary for the given crn
         * @param {string} crn crn
         * @param {boolean} [authenticated] 
         * @param {string} [authorities0Authority] 
         * @param {object} [credentials] 
         * @param {object} [details] 
         * @param {object} [principal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOffenderSummaryByCrnUsingGET(crn: string, authenticated?: boolean, authorities0Authority?: string, credentials?: object, details?: object, principal?: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OffenderDetailSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOffenderSummaryByCrnUsingGET(crn, authenticated, authorities0Authority, credentials, details, principal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accepts a NOMIS offender nomsNumber in the format A9999AA
         * @summary Return the responsible officer (RO) for an offender
         * @param {string} nomsNumber Nomis number for the offender
         * @param {boolean} [current] Current only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResponsibleOfficersForOffenderUsingGET(nomsNumber: string, current?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResponsibleOfficer>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResponsibleOfficersForOffenderUsingGET(nomsNumber, current, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return sentence and custodial status information by crn, convictionId.
         * @param {number} convictionId ID for the conviction / event
         * @param {string} crn CRN for the offender
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSentenceStatusByConvictionIdUsingGET(convictionId: number, crn: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SentenceStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSentenceStatusByConvictionIdUsingGET(convictionId, crn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Requires role ROLE_COMMUNITY_CUSTODY_UPDATE
         * @summary Sets the responsible officer for an offender to either the current prison offender manager to community offender manager. This will allow the responsible officer to be set to an unallocated offender manager
         * @param {string} nomsNumber nomsNumber
         * @param {ResponsibleOfficerSwitch} responsibleOfficerSwitch responsibleOfficerSwitch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async switchResponsibleOfficerUsingPUT(nomsNumber: string, responsibleOfficerSwitch: ResponsibleOfficerSwitch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommunityOrPrisonOffenderManager>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.switchResponsibleOfficerUsingPUT(nomsNumber, responsibleOfficerSwitch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update offender tier. Requires ROLE_MANAGEMENT_TIER_UPDATE
         * @param {string} crn CRN for the offender
         * @param {'A0' | 'A1' | 'A2' | 'A3' | 'B0' | 'B1' | 'B2' | 'B3' | 'C0' | 'C1' | 'C2' | 'C3' | 'D0' | 'D1' | 'D2' | 'D3'} tier New tier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTierUsingPOST(crn: string, tier: 'A0' | 'A1' | 'A2' | 'A3' | 'B0' | 'B1' | 'B2' | 'B3' | 'C0' | 'C1' | 'C2' | 'C3' | 'D0' | 'D1' | 'D2' | 'D3', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTierUsingPOST(crn, tier, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CoreOffenderApi - factory interface
 * @export
 */
export const CoreOffenderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoreOffenderApiFp(configuration)
    return {
        /**
         * Requires role ROLE_COMMUNITY_CUSTODY_UPDATE
         * @summary Allocates the prison offender manager for an offender in custody. This operation may also have a side affect of creating a Staff member if one matching the name does not already exist. An existing staff member can be used if the staff id is supplied.
         * @param {string} nomsNumber nomsNumber
         * @param {CreatePrisonOffenderManager} prisonOffenderManager prisonOffenderManager
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allocatePrisonOffenderManagerByNomsNumberUsingPUT(nomsNumber: string, prisonOffenderManager: CreatePrisonOffenderManager, options?: any): AxiosPromise<CommunityOrPrisonOffenderManager> {
            return localVarFp.allocatePrisonOffenderManagerByNomsNumberUsingPUT(nomsNumber, prisonOffenderManager, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reveals if the logged on user can access details about the supplied offender
         * @param {string} crn crn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUserAccessByCrnUsingGET(crn: string, options?: any): AxiosPromise<AccessLimitation> {
            return localVarFp.checkUserAccessByCrnUsingGET(crn, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires role ROLE_COMMUNITY_CUSTODY_UPDATE
         * @summary Deallocates the prison offender manager for an offender in custody. The POM is set back to its unallocated state
         * @param {string} nomsNumber nomsNumber
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deallocatePrisonOffenderManagerByNomsNumberUsingDELETE(nomsNumber: string, options?: any): AxiosPromise<void> {
            return localVarFp.deallocatePrisonOffenderManagerByNomsNumberUsingDELETE(nomsNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts a NOMIS offender nomsNumber in the format A9999AA
         * @summary Returns the current community and prison offender managers for an offender
         * @param {string} nomsNumber Nomis number for the offender
         * @param {boolean} [includeProbationAreaTeams] include teams on the ProbationArea records
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOffenderManagersForOffenderUsingGET(nomsNumber: string, includeProbationAreaTeams?: boolean, options?: any): AxiosPromise<Array<CommunityOrPrisonOffenderManager>> {
            return localVarFp.getAllOffenderManagersForOffenderUsingGET(nomsNumber, includeProbationAreaTeams, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts an offender CRN in the format A999999
         * @summary Returns the current community and prison offender managers for an offender
         * @param {string} crn CRN for the offender
         * @param {boolean} [includeProbationAreaTeams] include teams on the ProbationArea records
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOffenderManagersForOffenderbyCrnUsingGET(crn: string, includeProbationAreaTeams?: boolean, options?: any): AxiosPromise<Array<CommunityOrPrisonOffenderManager>> {
            return localVarFp.getAllOffenderManagersForOffenderbyCrnUsingGET(crn, includeProbationAreaTeams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the assessments for a CRN
         * @param {string} crn CRN for the offender
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssessmentsByCrnUsingGET(crn: string, options?: any): AxiosPromise<OffenderAssessments> {
            return localVarFp.getAssessmentsByCrnUsingGET(crn, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the conviction (AKA Delius Event) for a conviction ID and a CRN
         * @param {number} convictionId ID for the conviction / event
         * @param {string} crn CRN for the offender
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConvictionForOffenderByCrnAndConvictionIdUsingGET(convictionId: number, crn: string, options?: any): AxiosPromise<Conviction> {
            return localVarFp.getConvictionForOffenderByCrnAndConvictionIdUsingGET(convictionId, crn, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the convictions (AKA Delius Event) for an offender
         * @param {string} crn CRN for the offender
         * @param {boolean} [activeOnly] retrieve only active convictions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConvictionsForOffenderByCrnUsingGET(crn: string, activeOnly?: boolean, options?: any): AxiosPromise<Array<Conviction>> {
            return localVarFp.getConvictionsForOffenderByCrnUsingGET(crn, activeOnly, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the convictions (AKA Delius Event) for an offender
         * @param {string} nomsNumber Nomis number for the offender
         * @param {boolean} [activeOnly] retrieve only active convictions
         * @param {boolean} [failOnDuplicate] Should fail if multiple offenders found regardless of status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConvictionsForOffenderUsingGET(nomsNumber: string, activeOnly?: boolean, failOnDuplicate?: boolean, options?: any): AxiosPromise<Array<Conviction>> {
            return localVarFp.getConvictionsForOffenderUsingGET(nomsNumber, activeOnly, failOnDuplicate, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts an offender CRN in the format A999999
         * @summary Returns the latest recall and release details for an offender
         * @param {string} crn CRN for the offender
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestRecallAndReleaseForOffenderByCrnUsingGET(crn: string, options?: any): AxiosPromise<OffenderLatestRecall> {
            return localVarFp.getLatestRecallAndReleaseForOffenderByCrnUsingGET(crn, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts a NOMIS offender nomsNumber in the format A9999AA
         * @summary Returns the latest recall and release details for an offender
         * @param {string} nomsNumber Nomis number for the offender
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestRecallAndReleaseForOffenderUsingGET(nomsNumber: string, options?: any): AxiosPromise<OffenderLatestRecall> {
            return localVarFp.getLatestRecallAndReleaseForOffenderUsingGET(nomsNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return an NSI by crn, convictionId and nsiId
         * @param {number} convictionId ID for the conviction / event
         * @param {string} crn CRN for the offender
         * @param {number} nsiId ID for the nsi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNsiByNsiIdUsingGET(convictionId: number, crn: string, nsiId: number, options?: any): AxiosPromise<Nsi> {
            return localVarFp.getNsiByNsiIdUsingGET(convictionId, crn, nsiId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the NSIs for a conviction ID and a CRN, filtering by NSI codes
         * @param {number} convictionId ID for the conviction / event
         * @param {string} crn CRN for the offender
         * @param {Array<string>} nsiCodes list of NSI codes to constrain by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNsiForOffenderByCrnAndConvictionIdUsingGET(convictionId: number, crn: string, nsiCodes: Array<string>, options?: any): AxiosPromise<NsiWrapper> {
            return localVarFp.getNsiForOffenderByCrnAndConvictionIdUsingGET(convictionId, crn, nsiCodes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return all the NSIs for the CRN, active convictions only, filtering by NSI codes
         * @param {string} crn CRN for the offender
         * @param {Array<string>} nsiCodes list of NSI codes to constrain by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNsisForOffenderByCrnAndActiveConvictionsUsingGET(crn: string, nsiCodes: Array<string>, options?: any): AxiosPromise<NsiWrapper> {
            return localVarFp.getNsisForOffenderByCrnAndActiveConvictionsUsingGET(crn, nsiCodes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the contact details for an offender
         * @param {Array<string>} contactTypes contactTypes
         * @param {string} from from
         * @param {string} nomsNumber Nomis number for the offender
         * @param {string} to to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffenderContactReportByNomsNumberUsingGET(contactTypes: Array<string>, from: string, nomsNumber: string, to: string, options?: any): AxiosPromise<Array<Contact>> {
            return localVarFp.getOffenderContactReportByNomsNumberUsingGET(contactTypes, from, nomsNumber, to, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the convictions (AKA Delius Event) for an offender that contain RAR
         * @param {string} crn CRN for the offender
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffenderConvictionsWithRarByCrnUsingGET(crn: string, options?: any): AxiosPromise<Array<Conviction>> {
            return localVarFp.getOffenderConvictionsWithRarByCrnUsingGET(crn, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the full offender detail for the given crn
         * @param {string} crn crn
         * @param {boolean} [authenticated] 
         * @param {string} [authorities0Authority] 
         * @param {object} [credentials] 
         * @param {object} [details] 
         * @param {object} [principal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffenderDetailByCrnUsingGET(crn: string, authenticated?: boolean, authorities0Authority?: string, credentials?: object, details?: object, principal?: object, options?: any): AxiosPromise<OffenderDetail> {
            return localVarFp.getOffenderDetailByCrnUsingGET(crn, authenticated, authorities0Authority, credentials, details, principal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the full offender detail for the given nomsNumber. If multiple offender found the active one will be returned
         * @param {string} nomsNumber Nomis number for the offender
         * @param {boolean} [failOnDuplicate] Should fail if multiple offenders found
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffenderDetailByNomsNumberUsingGET(nomsNumber: string, failOnDuplicate?: boolean, options?: any): AxiosPromise<OffenderDetail> {
            return localVarFp.getOffenderDetailByNomsNumberUsingGET(nomsNumber, failOnDuplicate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the details for an offender. If multiple offenders found the active one wll be returned
         * @param {string} nomsNumber Nomis number for the offender
         * @param {boolean} [failOnDuplicate] Should fail if multiple offenders found regardless of status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffenderDetailsUsingGET(nomsNumber: string, failOnDuplicate?: boolean, options?: any): AxiosPromise<OffenderDetailSummary> {
            return localVarFp.getOffenderDetailsUsingGET(nomsNumber, failOnDuplicate, options).then((request) => request(axios, basePath));
        },
        /**
         * requires ROLE_COMMUNITY
         * @summary Return the identifiers for an offender using the crn
         * @param {string} crn crn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffenderIdentifiersByCrnUsingGET(crn: string, options?: any): AxiosPromise<OffenderIdentifiers> {
            return localVarFp.getOffenderIdentifiersByCrnUsingGET(crn, options).then((request) => request(axios, basePath));
        },
        /**
         * requires ROLE_COMMUNITY
         * @summary Return the identifiers for an offender using NOMS number
         * @param {string} nomsNumber nomsNumber
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffenderIdentifiersByNomsNumberUsingGET(nomsNumber: string, options?: any): AxiosPromise<OffenderIdentifiers> {
            return localVarFp.getOffenderIdentifiersByNomsNumberUsingGET(nomsNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * requires ROLE_COMMUNITY
         * @summary Return the identifiers for an offender using offenderId
         * @param {number} offenderId offenderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffenderIdentifiersByOffenderIdUsingGET(offenderId: number, options?: any): AxiosPromise<OffenderIdentifiers> {
            return localVarFp.getOffenderIdentifiersByOffenderIdUsingGET(offenderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return pageable list of all offender identifiers that match the supplied filter
         * @param {string} [activeDate] Filter by offenders that were active on the supplied date. Advised not to use this in conjunction with includeActiveOnly since that will effectively return offenders active of this supplied date and current date which is typically not what is required.
         * @param {boolean} [includeActiveOnly] Filter by offenders that are active, i.e. offenders on a sentence that probation has an interest in.
         * @param {boolean} [includeDeleted] Include deleted offenders
         * @param {number} [offset] 
         * @param {number} [page] Results page you want to retrieve (0..N)
         * @param {boolean} [paged] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {number} [size] Number of records per page.
         * @param {string} [sort] Sort column and direction. Multiple sort params allowed.
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffenderIdsUsingGET(activeDate?: string, includeActiveOnly?: boolean, includeDeleted?: boolean, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any): AxiosPromise<PageOfPrimaryIdentifiers> {
            return localVarFp.getOffenderIdsUsingGET(activeDate, includeActiveOnly, includeDeleted, offset, page, paged, pageNumber, pageSize, size, sort, sortSorted, sortUnsorted, unpaged, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the probation status for the given crn
         * @param {string} crn crn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffenderProbationStatusByCrnUsingGET(crn: string, options?: any): AxiosPromise<ProbationStatusDetail> {
            return localVarFp.getOffenderProbationStatusByCrnUsingGET(crn, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the offender summary for the given crn
         * @param {string} crn crn
         * @param {boolean} [authenticated] 
         * @param {string} [authorities0Authority] 
         * @param {object} [credentials] 
         * @param {object} [details] 
         * @param {object} [principal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffenderSummaryByCrnUsingGET(crn: string, authenticated?: boolean, authorities0Authority?: string, credentials?: object, details?: object, principal?: object, options?: any): AxiosPromise<OffenderDetailSummary> {
            return localVarFp.getOffenderSummaryByCrnUsingGET(crn, authenticated, authorities0Authority, credentials, details, principal, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts a NOMIS offender nomsNumber in the format A9999AA
         * @summary Return the responsible officer (RO) for an offender
         * @param {string} nomsNumber Nomis number for the offender
         * @param {boolean} [current] Current only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResponsibleOfficersForOffenderUsingGET(nomsNumber: string, current?: boolean, options?: any): AxiosPromise<Array<ResponsibleOfficer>> {
            return localVarFp.getResponsibleOfficersForOffenderUsingGET(nomsNumber, current, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return sentence and custodial status information by crn, convictionId.
         * @param {number} convictionId ID for the conviction / event
         * @param {string} crn CRN for the offender
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSentenceStatusByConvictionIdUsingGET(convictionId: number, crn: string, options?: any): AxiosPromise<SentenceStatus> {
            return localVarFp.getSentenceStatusByConvictionIdUsingGET(convictionId, crn, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires role ROLE_COMMUNITY_CUSTODY_UPDATE
         * @summary Sets the responsible officer for an offender to either the current prison offender manager to community offender manager. This will allow the responsible officer to be set to an unallocated offender manager
         * @param {string} nomsNumber nomsNumber
         * @param {ResponsibleOfficerSwitch} responsibleOfficerSwitch responsibleOfficerSwitch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        switchResponsibleOfficerUsingPUT(nomsNumber: string, responsibleOfficerSwitch: ResponsibleOfficerSwitch, options?: any): AxiosPromise<CommunityOrPrisonOffenderManager> {
            return localVarFp.switchResponsibleOfficerUsingPUT(nomsNumber, responsibleOfficerSwitch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update offender tier. Requires ROLE_MANAGEMENT_TIER_UPDATE
         * @param {string} crn CRN for the offender
         * @param {'A0' | 'A1' | 'A2' | 'A3' | 'B0' | 'B1' | 'B2' | 'B3' | 'C0' | 'C1' | 'C2' | 'C3' | 'D0' | 'D1' | 'D2' | 'D3'} tier New tier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTierUsingPOST(crn: string, tier: 'A0' | 'A1' | 'A2' | 'A3' | 'B0' | 'B1' | 'B2' | 'B3' | 'C0' | 'C1' | 'C2' | 'C3' | 'D0' | 'D1' | 'D2' | 'D3', options?: any): AxiosPromise<void> {
            return localVarFp.updateTierUsingPOST(crn, tier, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for allocatePrisonOffenderManagerByNomsNumberUsingPUT operation in CoreOffenderApi.
 * @export
 * @interface CoreOffenderApiAllocatePrisonOffenderManagerByNomsNumberUsingPUTRequest
 */
export interface CoreOffenderApiAllocatePrisonOffenderManagerByNomsNumberUsingPUTRequest {
    /**
     * nomsNumber
     * @type {string}
     * @memberof CoreOffenderApiAllocatePrisonOffenderManagerByNomsNumberUsingPUT
     */
    readonly nomsNumber: string

    /**
     * prisonOffenderManager
     * @type {CreatePrisonOffenderManager}
     * @memberof CoreOffenderApiAllocatePrisonOffenderManagerByNomsNumberUsingPUT
     */
    readonly prisonOffenderManager: CreatePrisonOffenderManager
}

/**
 * Request parameters for checkUserAccessByCrnUsingGET operation in CoreOffenderApi.
 * @export
 * @interface CoreOffenderApiCheckUserAccessByCrnUsingGETRequest
 */
export interface CoreOffenderApiCheckUserAccessByCrnUsingGETRequest {
    /**
     * crn
     * @type {string}
     * @memberof CoreOffenderApiCheckUserAccessByCrnUsingGET
     */
    readonly crn: string
}

/**
 * Request parameters for deallocatePrisonOffenderManagerByNomsNumberUsingDELETE operation in CoreOffenderApi.
 * @export
 * @interface CoreOffenderApiDeallocatePrisonOffenderManagerByNomsNumberUsingDELETERequest
 */
export interface CoreOffenderApiDeallocatePrisonOffenderManagerByNomsNumberUsingDELETERequest {
    /**
     * nomsNumber
     * @type {string}
     * @memberof CoreOffenderApiDeallocatePrisonOffenderManagerByNomsNumberUsingDELETE
     */
    readonly nomsNumber: string
}

/**
 * Request parameters for getAllOffenderManagersForOffenderUsingGET operation in CoreOffenderApi.
 * @export
 * @interface CoreOffenderApiGetAllOffenderManagersForOffenderUsingGETRequest
 */
export interface CoreOffenderApiGetAllOffenderManagersForOffenderUsingGETRequest {
    /**
     * Nomis number for the offender
     * @type {string}
     * @memberof CoreOffenderApiGetAllOffenderManagersForOffenderUsingGET
     */
    readonly nomsNumber: string

    /**
     * include teams on the ProbationArea records
     * @type {boolean}
     * @memberof CoreOffenderApiGetAllOffenderManagersForOffenderUsingGET
     */
    readonly includeProbationAreaTeams?: boolean
}

/**
 * Request parameters for getAllOffenderManagersForOffenderbyCrnUsingGET operation in CoreOffenderApi.
 * @export
 * @interface CoreOffenderApiGetAllOffenderManagersForOffenderbyCrnUsingGETRequest
 */
export interface CoreOffenderApiGetAllOffenderManagersForOffenderbyCrnUsingGETRequest {
    /**
     * CRN for the offender
     * @type {string}
     * @memberof CoreOffenderApiGetAllOffenderManagersForOffenderbyCrnUsingGET
     */
    readonly crn: string

    /**
     * include teams on the ProbationArea records
     * @type {boolean}
     * @memberof CoreOffenderApiGetAllOffenderManagersForOffenderbyCrnUsingGET
     */
    readonly includeProbationAreaTeams?: boolean
}

/**
 * Request parameters for getAssessmentsByCrnUsingGET operation in CoreOffenderApi.
 * @export
 * @interface CoreOffenderApiGetAssessmentsByCrnUsingGETRequest
 */
export interface CoreOffenderApiGetAssessmentsByCrnUsingGETRequest {
    /**
     * CRN for the offender
     * @type {string}
     * @memberof CoreOffenderApiGetAssessmentsByCrnUsingGET
     */
    readonly crn: string
}

/**
 * Request parameters for getConvictionForOffenderByCrnAndConvictionIdUsingGET operation in CoreOffenderApi.
 * @export
 * @interface CoreOffenderApiGetConvictionForOffenderByCrnAndConvictionIdUsingGETRequest
 */
export interface CoreOffenderApiGetConvictionForOffenderByCrnAndConvictionIdUsingGETRequest {
    /**
     * ID for the conviction / event
     * @type {number}
     * @memberof CoreOffenderApiGetConvictionForOffenderByCrnAndConvictionIdUsingGET
     */
    readonly convictionId: number

    /**
     * CRN for the offender
     * @type {string}
     * @memberof CoreOffenderApiGetConvictionForOffenderByCrnAndConvictionIdUsingGET
     */
    readonly crn: string
}

/**
 * Request parameters for getConvictionsForOffenderByCrnUsingGET operation in CoreOffenderApi.
 * @export
 * @interface CoreOffenderApiGetConvictionsForOffenderByCrnUsingGETRequest
 */
export interface CoreOffenderApiGetConvictionsForOffenderByCrnUsingGETRequest {
    /**
     * CRN for the offender
     * @type {string}
     * @memberof CoreOffenderApiGetConvictionsForOffenderByCrnUsingGET
     */
    readonly crn: string

    /**
     * retrieve only active convictions
     * @type {boolean}
     * @memberof CoreOffenderApiGetConvictionsForOffenderByCrnUsingGET
     */
    readonly activeOnly?: boolean
}

/**
 * Request parameters for getConvictionsForOffenderUsingGET operation in CoreOffenderApi.
 * @export
 * @interface CoreOffenderApiGetConvictionsForOffenderUsingGETRequest
 */
export interface CoreOffenderApiGetConvictionsForOffenderUsingGETRequest {
    /**
     * Nomis number for the offender
     * @type {string}
     * @memberof CoreOffenderApiGetConvictionsForOffenderUsingGET
     */
    readonly nomsNumber: string

    /**
     * retrieve only active convictions
     * @type {boolean}
     * @memberof CoreOffenderApiGetConvictionsForOffenderUsingGET
     */
    readonly activeOnly?: boolean

    /**
     * Should fail if multiple offenders found regardless of status
     * @type {boolean}
     * @memberof CoreOffenderApiGetConvictionsForOffenderUsingGET
     */
    readonly failOnDuplicate?: boolean
}

/**
 * Request parameters for getLatestRecallAndReleaseForOffenderByCrnUsingGET operation in CoreOffenderApi.
 * @export
 * @interface CoreOffenderApiGetLatestRecallAndReleaseForOffenderByCrnUsingGETRequest
 */
export interface CoreOffenderApiGetLatestRecallAndReleaseForOffenderByCrnUsingGETRequest {
    /**
     * CRN for the offender
     * @type {string}
     * @memberof CoreOffenderApiGetLatestRecallAndReleaseForOffenderByCrnUsingGET
     */
    readonly crn: string
}

/**
 * Request parameters for getLatestRecallAndReleaseForOffenderUsingGET operation in CoreOffenderApi.
 * @export
 * @interface CoreOffenderApiGetLatestRecallAndReleaseForOffenderUsingGETRequest
 */
export interface CoreOffenderApiGetLatestRecallAndReleaseForOffenderUsingGETRequest {
    /**
     * Nomis number for the offender
     * @type {string}
     * @memberof CoreOffenderApiGetLatestRecallAndReleaseForOffenderUsingGET
     */
    readonly nomsNumber: string
}

/**
 * Request parameters for getNsiByNsiIdUsingGET operation in CoreOffenderApi.
 * @export
 * @interface CoreOffenderApiGetNsiByNsiIdUsingGETRequest
 */
export interface CoreOffenderApiGetNsiByNsiIdUsingGETRequest {
    /**
     * ID for the conviction / event
     * @type {number}
     * @memberof CoreOffenderApiGetNsiByNsiIdUsingGET
     */
    readonly convictionId: number

    /**
     * CRN for the offender
     * @type {string}
     * @memberof CoreOffenderApiGetNsiByNsiIdUsingGET
     */
    readonly crn: string

    /**
     * ID for the nsi
     * @type {number}
     * @memberof CoreOffenderApiGetNsiByNsiIdUsingGET
     */
    readonly nsiId: number
}

/**
 * Request parameters for getNsiForOffenderByCrnAndConvictionIdUsingGET operation in CoreOffenderApi.
 * @export
 * @interface CoreOffenderApiGetNsiForOffenderByCrnAndConvictionIdUsingGETRequest
 */
export interface CoreOffenderApiGetNsiForOffenderByCrnAndConvictionIdUsingGETRequest {
    /**
     * ID for the conviction / event
     * @type {number}
     * @memberof CoreOffenderApiGetNsiForOffenderByCrnAndConvictionIdUsingGET
     */
    readonly convictionId: number

    /**
     * CRN for the offender
     * @type {string}
     * @memberof CoreOffenderApiGetNsiForOffenderByCrnAndConvictionIdUsingGET
     */
    readonly crn: string

    /**
     * list of NSI codes to constrain by
     * @type {Array<string>}
     * @memberof CoreOffenderApiGetNsiForOffenderByCrnAndConvictionIdUsingGET
     */
    readonly nsiCodes: Array<string>
}

/**
 * Request parameters for getNsisForOffenderByCrnAndActiveConvictionsUsingGET operation in CoreOffenderApi.
 * @export
 * @interface CoreOffenderApiGetNsisForOffenderByCrnAndActiveConvictionsUsingGETRequest
 */
export interface CoreOffenderApiGetNsisForOffenderByCrnAndActiveConvictionsUsingGETRequest {
    /**
     * CRN for the offender
     * @type {string}
     * @memberof CoreOffenderApiGetNsisForOffenderByCrnAndActiveConvictionsUsingGET
     */
    readonly crn: string

    /**
     * list of NSI codes to constrain by
     * @type {Array<string>}
     * @memberof CoreOffenderApiGetNsisForOffenderByCrnAndActiveConvictionsUsingGET
     */
    readonly nsiCodes: Array<string>
}

/**
 * Request parameters for getOffenderContactReportByNomsNumberUsingGET operation in CoreOffenderApi.
 * @export
 * @interface CoreOffenderApiGetOffenderContactReportByNomsNumberUsingGETRequest
 */
export interface CoreOffenderApiGetOffenderContactReportByNomsNumberUsingGETRequest {
    /**
     * contactTypes
     * @type {Array<string>}
     * @memberof CoreOffenderApiGetOffenderContactReportByNomsNumberUsingGET
     */
    readonly contactTypes: Array<string>

    /**
     * from
     * @type {string}
     * @memberof CoreOffenderApiGetOffenderContactReportByNomsNumberUsingGET
     */
    readonly from: string

    /**
     * Nomis number for the offender
     * @type {string}
     * @memberof CoreOffenderApiGetOffenderContactReportByNomsNumberUsingGET
     */
    readonly nomsNumber: string

    /**
     * to
     * @type {string}
     * @memberof CoreOffenderApiGetOffenderContactReportByNomsNumberUsingGET
     */
    readonly to: string
}

/**
 * Request parameters for getOffenderConvictionsWithRarByCrnUsingGET operation in CoreOffenderApi.
 * @export
 * @interface CoreOffenderApiGetOffenderConvictionsWithRarByCrnUsingGETRequest
 */
export interface CoreOffenderApiGetOffenderConvictionsWithRarByCrnUsingGETRequest {
    /**
     * CRN for the offender
     * @type {string}
     * @memberof CoreOffenderApiGetOffenderConvictionsWithRarByCrnUsingGET
     */
    readonly crn: string
}

/**
 * Request parameters for getOffenderDetailByCrnUsingGET operation in CoreOffenderApi.
 * @export
 * @interface CoreOffenderApiGetOffenderDetailByCrnUsingGETRequest
 */
export interface CoreOffenderApiGetOffenderDetailByCrnUsingGETRequest {
    /**
     * crn
     * @type {string}
     * @memberof CoreOffenderApiGetOffenderDetailByCrnUsingGET
     */
    readonly crn: string

    /**
     * 
     * @type {boolean}
     * @memberof CoreOffenderApiGetOffenderDetailByCrnUsingGET
     */
    readonly authenticated?: boolean

    /**
     * 
     * @type {string}
     * @memberof CoreOffenderApiGetOffenderDetailByCrnUsingGET
     */
    readonly authorities0Authority?: string

    /**
     * 
     * @type {object}
     * @memberof CoreOffenderApiGetOffenderDetailByCrnUsingGET
     */
    readonly credentials?: object

    /**
     * 
     * @type {object}
     * @memberof CoreOffenderApiGetOffenderDetailByCrnUsingGET
     */
    readonly details?: object

    /**
     * 
     * @type {object}
     * @memberof CoreOffenderApiGetOffenderDetailByCrnUsingGET
     */
    readonly principal?: object
}

/**
 * Request parameters for getOffenderDetailByNomsNumberUsingGET operation in CoreOffenderApi.
 * @export
 * @interface CoreOffenderApiGetOffenderDetailByNomsNumberUsingGETRequest
 */
export interface CoreOffenderApiGetOffenderDetailByNomsNumberUsingGETRequest {
    /**
     * Nomis number for the offender
     * @type {string}
     * @memberof CoreOffenderApiGetOffenderDetailByNomsNumberUsingGET
     */
    readonly nomsNumber: string

    /**
     * Should fail if multiple offenders found
     * @type {boolean}
     * @memberof CoreOffenderApiGetOffenderDetailByNomsNumberUsingGET
     */
    readonly failOnDuplicate?: boolean
}

/**
 * Request parameters for getOffenderDetailsUsingGET operation in CoreOffenderApi.
 * @export
 * @interface CoreOffenderApiGetOffenderDetailsUsingGETRequest
 */
export interface CoreOffenderApiGetOffenderDetailsUsingGETRequest {
    /**
     * Nomis number for the offender
     * @type {string}
     * @memberof CoreOffenderApiGetOffenderDetailsUsingGET
     */
    readonly nomsNumber: string

    /**
     * Should fail if multiple offenders found regardless of status
     * @type {boolean}
     * @memberof CoreOffenderApiGetOffenderDetailsUsingGET
     */
    readonly failOnDuplicate?: boolean
}

/**
 * Request parameters for getOffenderIdentifiersByCrnUsingGET operation in CoreOffenderApi.
 * @export
 * @interface CoreOffenderApiGetOffenderIdentifiersByCrnUsingGETRequest
 */
export interface CoreOffenderApiGetOffenderIdentifiersByCrnUsingGETRequest {
    /**
     * crn
     * @type {string}
     * @memberof CoreOffenderApiGetOffenderIdentifiersByCrnUsingGET
     */
    readonly crn: string
}

/**
 * Request parameters for getOffenderIdentifiersByNomsNumberUsingGET operation in CoreOffenderApi.
 * @export
 * @interface CoreOffenderApiGetOffenderIdentifiersByNomsNumberUsingGETRequest
 */
export interface CoreOffenderApiGetOffenderIdentifiersByNomsNumberUsingGETRequest {
    /**
     * nomsNumber
     * @type {string}
     * @memberof CoreOffenderApiGetOffenderIdentifiersByNomsNumberUsingGET
     */
    readonly nomsNumber: string
}

/**
 * Request parameters for getOffenderIdentifiersByOffenderIdUsingGET operation in CoreOffenderApi.
 * @export
 * @interface CoreOffenderApiGetOffenderIdentifiersByOffenderIdUsingGETRequest
 */
export interface CoreOffenderApiGetOffenderIdentifiersByOffenderIdUsingGETRequest {
    /**
     * offenderId
     * @type {number}
     * @memberof CoreOffenderApiGetOffenderIdentifiersByOffenderIdUsingGET
     */
    readonly offenderId: number
}

/**
 * Request parameters for getOffenderIdsUsingGET operation in CoreOffenderApi.
 * @export
 * @interface CoreOffenderApiGetOffenderIdsUsingGETRequest
 */
export interface CoreOffenderApiGetOffenderIdsUsingGETRequest {
    /**
     * Filter by offenders that were active on the supplied date. Advised not to use this in conjunction with includeActiveOnly since that will effectively return offenders active of this supplied date and current date which is typically not what is required.
     * @type {string}
     * @memberof CoreOffenderApiGetOffenderIdsUsingGET
     */
    readonly activeDate?: string

    /**
     * Filter by offenders that are active, i.e. offenders on a sentence that probation has an interest in.
     * @type {boolean}
     * @memberof CoreOffenderApiGetOffenderIdsUsingGET
     */
    readonly includeActiveOnly?: boolean

    /**
     * Include deleted offenders
     * @type {boolean}
     * @memberof CoreOffenderApiGetOffenderIdsUsingGET
     */
    readonly includeDeleted?: boolean

    /**
     * 
     * @type {number}
     * @memberof CoreOffenderApiGetOffenderIdsUsingGET
     */
    readonly offset?: number

    /**
     * Results page you want to retrieve (0..N)
     * @type {number}
     * @memberof CoreOffenderApiGetOffenderIdsUsingGET
     */
    readonly page?: number

    /**
     * 
     * @type {boolean}
     * @memberof CoreOffenderApiGetOffenderIdsUsingGET
     */
    readonly paged?: boolean

    /**
     * 
     * @type {number}
     * @memberof CoreOffenderApiGetOffenderIdsUsingGET
     */
    readonly pageNumber?: number

    /**
     * 
     * @type {number}
     * @memberof CoreOffenderApiGetOffenderIdsUsingGET
     */
    readonly pageSize?: number

    /**
     * Number of records per page.
     * @type {number}
     * @memberof CoreOffenderApiGetOffenderIdsUsingGET
     */
    readonly size?: number

    /**
     * Sort column and direction. Multiple sort params allowed.
     * @type {string}
     * @memberof CoreOffenderApiGetOffenderIdsUsingGET
     */
    readonly sort?: string

    /**
     * 
     * @type {boolean}
     * @memberof CoreOffenderApiGetOffenderIdsUsingGET
     */
    readonly sortSorted?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof CoreOffenderApiGetOffenderIdsUsingGET
     */
    readonly sortUnsorted?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof CoreOffenderApiGetOffenderIdsUsingGET
     */
    readonly unpaged?: boolean
}

/**
 * Request parameters for getOffenderProbationStatusByCrnUsingGET operation in CoreOffenderApi.
 * @export
 * @interface CoreOffenderApiGetOffenderProbationStatusByCrnUsingGETRequest
 */
export interface CoreOffenderApiGetOffenderProbationStatusByCrnUsingGETRequest {
    /**
     * crn
     * @type {string}
     * @memberof CoreOffenderApiGetOffenderProbationStatusByCrnUsingGET
     */
    readonly crn: string
}

/**
 * Request parameters for getOffenderSummaryByCrnUsingGET operation in CoreOffenderApi.
 * @export
 * @interface CoreOffenderApiGetOffenderSummaryByCrnUsingGETRequest
 */
export interface CoreOffenderApiGetOffenderSummaryByCrnUsingGETRequest {
    /**
     * crn
     * @type {string}
     * @memberof CoreOffenderApiGetOffenderSummaryByCrnUsingGET
     */
    readonly crn: string

    /**
     * 
     * @type {boolean}
     * @memberof CoreOffenderApiGetOffenderSummaryByCrnUsingGET
     */
    readonly authenticated?: boolean

    /**
     * 
     * @type {string}
     * @memberof CoreOffenderApiGetOffenderSummaryByCrnUsingGET
     */
    readonly authorities0Authority?: string

    /**
     * 
     * @type {object}
     * @memberof CoreOffenderApiGetOffenderSummaryByCrnUsingGET
     */
    readonly credentials?: object

    /**
     * 
     * @type {object}
     * @memberof CoreOffenderApiGetOffenderSummaryByCrnUsingGET
     */
    readonly details?: object

    /**
     * 
     * @type {object}
     * @memberof CoreOffenderApiGetOffenderSummaryByCrnUsingGET
     */
    readonly principal?: object
}

/**
 * Request parameters for getResponsibleOfficersForOffenderUsingGET operation in CoreOffenderApi.
 * @export
 * @interface CoreOffenderApiGetResponsibleOfficersForOffenderUsingGETRequest
 */
export interface CoreOffenderApiGetResponsibleOfficersForOffenderUsingGETRequest {
    /**
     * Nomis number for the offender
     * @type {string}
     * @memberof CoreOffenderApiGetResponsibleOfficersForOffenderUsingGET
     */
    readonly nomsNumber: string

    /**
     * Current only
     * @type {boolean}
     * @memberof CoreOffenderApiGetResponsibleOfficersForOffenderUsingGET
     */
    readonly current?: boolean
}

/**
 * Request parameters for getSentenceStatusByConvictionIdUsingGET operation in CoreOffenderApi.
 * @export
 * @interface CoreOffenderApiGetSentenceStatusByConvictionIdUsingGETRequest
 */
export interface CoreOffenderApiGetSentenceStatusByConvictionIdUsingGETRequest {
    /**
     * ID for the conviction / event
     * @type {number}
     * @memberof CoreOffenderApiGetSentenceStatusByConvictionIdUsingGET
     */
    readonly convictionId: number

    /**
     * CRN for the offender
     * @type {string}
     * @memberof CoreOffenderApiGetSentenceStatusByConvictionIdUsingGET
     */
    readonly crn: string
}

/**
 * Request parameters for switchResponsibleOfficerUsingPUT operation in CoreOffenderApi.
 * @export
 * @interface CoreOffenderApiSwitchResponsibleOfficerUsingPUTRequest
 */
export interface CoreOffenderApiSwitchResponsibleOfficerUsingPUTRequest {
    /**
     * nomsNumber
     * @type {string}
     * @memberof CoreOffenderApiSwitchResponsibleOfficerUsingPUT
     */
    readonly nomsNumber: string

    /**
     * responsibleOfficerSwitch
     * @type {ResponsibleOfficerSwitch}
     * @memberof CoreOffenderApiSwitchResponsibleOfficerUsingPUT
     */
    readonly responsibleOfficerSwitch: ResponsibleOfficerSwitch
}

/**
 * Request parameters for updateTierUsingPOST operation in CoreOffenderApi.
 * @export
 * @interface CoreOffenderApiUpdateTierUsingPOSTRequest
 */
export interface CoreOffenderApiUpdateTierUsingPOSTRequest {
    /**
     * CRN for the offender
     * @type {string}
     * @memberof CoreOffenderApiUpdateTierUsingPOST
     */
    readonly crn: string

    /**
     * New tier
     * @type {'A0' | 'A1' | 'A2' | 'A3' | 'B0' | 'B1' | 'B2' | 'B3' | 'C0' | 'C1' | 'C2' | 'C3' | 'D0' | 'D1' | 'D2' | 'D3'}
     * @memberof CoreOffenderApiUpdateTierUsingPOST
     */
    readonly tier: 'A0' | 'A1' | 'A2' | 'A3' | 'B0' | 'B1' | 'B2' | 'B3' | 'C0' | 'C1' | 'C2' | 'C3' | 'D0' | 'D1' | 'D2' | 'D3'
}

/**
 * CoreOffenderApi - object-oriented interface
 * @export
 * @class CoreOffenderApi
 * @extends {BaseAPI}
 */
export class CoreOffenderApi extends BaseAPI {
    /**
     * Requires role ROLE_COMMUNITY_CUSTODY_UPDATE
     * @summary Allocates the prison offender manager for an offender in custody. This operation may also have a side affect of creating a Staff member if one matching the name does not already exist. An existing staff member can be used if the staff id is supplied.
     * @param {CoreOffenderApiAllocatePrisonOffenderManagerByNomsNumberUsingPUTRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreOffenderApi
     */
    public allocatePrisonOffenderManagerByNomsNumberUsingPUT(requestParameters: CoreOffenderApiAllocatePrisonOffenderManagerByNomsNumberUsingPUTRequest, options?: any) {
        return CoreOffenderApiFp(this.configuration).allocatePrisonOffenderManagerByNomsNumberUsingPUT(requestParameters.nomsNumber, requestParameters.prisonOffenderManager, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reveals if the logged on user can access details about the supplied offender
     * @param {CoreOffenderApiCheckUserAccessByCrnUsingGETRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreOffenderApi
     */
    public checkUserAccessByCrnUsingGET(requestParameters: CoreOffenderApiCheckUserAccessByCrnUsingGETRequest, options?: any) {
        return CoreOffenderApiFp(this.configuration).checkUserAccessByCrnUsingGET(requestParameters.crn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requires role ROLE_COMMUNITY_CUSTODY_UPDATE
     * @summary Deallocates the prison offender manager for an offender in custody. The POM is set back to its unallocated state
     * @param {CoreOffenderApiDeallocatePrisonOffenderManagerByNomsNumberUsingDELETERequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreOffenderApi
     */
    public deallocatePrisonOffenderManagerByNomsNumberUsingDELETE(requestParameters: CoreOffenderApiDeallocatePrisonOffenderManagerByNomsNumberUsingDELETERequest, options?: any) {
        return CoreOffenderApiFp(this.configuration).deallocatePrisonOffenderManagerByNomsNumberUsingDELETE(requestParameters.nomsNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts a NOMIS offender nomsNumber in the format A9999AA
     * @summary Returns the current community and prison offender managers for an offender
     * @param {CoreOffenderApiGetAllOffenderManagersForOffenderUsingGETRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreOffenderApi
     */
    public getAllOffenderManagersForOffenderUsingGET(requestParameters: CoreOffenderApiGetAllOffenderManagersForOffenderUsingGETRequest, options?: any) {
        return CoreOffenderApiFp(this.configuration).getAllOffenderManagersForOffenderUsingGET(requestParameters.nomsNumber, requestParameters.includeProbationAreaTeams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts an offender CRN in the format A999999
     * @summary Returns the current community and prison offender managers for an offender
     * @param {CoreOffenderApiGetAllOffenderManagersForOffenderbyCrnUsingGETRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreOffenderApi
     */
    public getAllOffenderManagersForOffenderbyCrnUsingGET(requestParameters: CoreOffenderApiGetAllOffenderManagersForOffenderbyCrnUsingGETRequest, options?: any) {
        return CoreOffenderApiFp(this.configuration).getAllOffenderManagersForOffenderbyCrnUsingGET(requestParameters.crn, requestParameters.includeProbationAreaTeams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the assessments for a CRN
     * @param {CoreOffenderApiGetAssessmentsByCrnUsingGETRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreOffenderApi
     */
    public getAssessmentsByCrnUsingGET(requestParameters: CoreOffenderApiGetAssessmentsByCrnUsingGETRequest, options?: any) {
        return CoreOffenderApiFp(this.configuration).getAssessmentsByCrnUsingGET(requestParameters.crn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the conviction (AKA Delius Event) for a conviction ID and a CRN
     * @param {CoreOffenderApiGetConvictionForOffenderByCrnAndConvictionIdUsingGETRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreOffenderApi
     */
    public getConvictionForOffenderByCrnAndConvictionIdUsingGET(requestParameters: CoreOffenderApiGetConvictionForOffenderByCrnAndConvictionIdUsingGETRequest, options?: any) {
        return CoreOffenderApiFp(this.configuration).getConvictionForOffenderByCrnAndConvictionIdUsingGET(requestParameters.convictionId, requestParameters.crn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the convictions (AKA Delius Event) for an offender
     * @param {CoreOffenderApiGetConvictionsForOffenderByCrnUsingGETRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreOffenderApi
     */
    public getConvictionsForOffenderByCrnUsingGET(requestParameters: CoreOffenderApiGetConvictionsForOffenderByCrnUsingGETRequest, options?: any) {
        return CoreOffenderApiFp(this.configuration).getConvictionsForOffenderByCrnUsingGET(requestParameters.crn, requestParameters.activeOnly, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the convictions (AKA Delius Event) for an offender
     * @param {CoreOffenderApiGetConvictionsForOffenderUsingGETRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreOffenderApi
     */
    public getConvictionsForOffenderUsingGET(requestParameters: CoreOffenderApiGetConvictionsForOffenderUsingGETRequest, options?: any) {
        return CoreOffenderApiFp(this.configuration).getConvictionsForOffenderUsingGET(requestParameters.nomsNumber, requestParameters.activeOnly, requestParameters.failOnDuplicate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts an offender CRN in the format A999999
     * @summary Returns the latest recall and release details for an offender
     * @param {CoreOffenderApiGetLatestRecallAndReleaseForOffenderByCrnUsingGETRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreOffenderApi
     */
    public getLatestRecallAndReleaseForOffenderByCrnUsingGET(requestParameters: CoreOffenderApiGetLatestRecallAndReleaseForOffenderByCrnUsingGETRequest, options?: any) {
        return CoreOffenderApiFp(this.configuration).getLatestRecallAndReleaseForOffenderByCrnUsingGET(requestParameters.crn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts a NOMIS offender nomsNumber in the format A9999AA
     * @summary Returns the latest recall and release details for an offender
     * @param {CoreOffenderApiGetLatestRecallAndReleaseForOffenderUsingGETRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreOffenderApi
     */
    public getLatestRecallAndReleaseForOffenderUsingGET(requestParameters: CoreOffenderApiGetLatestRecallAndReleaseForOffenderUsingGETRequest, options?: any) {
        return CoreOffenderApiFp(this.configuration).getLatestRecallAndReleaseForOffenderUsingGET(requestParameters.nomsNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return an NSI by crn, convictionId and nsiId
     * @param {CoreOffenderApiGetNsiByNsiIdUsingGETRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreOffenderApi
     */
    public getNsiByNsiIdUsingGET(requestParameters: CoreOffenderApiGetNsiByNsiIdUsingGETRequest, options?: any) {
        return CoreOffenderApiFp(this.configuration).getNsiByNsiIdUsingGET(requestParameters.convictionId, requestParameters.crn, requestParameters.nsiId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the NSIs for a conviction ID and a CRN, filtering by NSI codes
     * @param {CoreOffenderApiGetNsiForOffenderByCrnAndConvictionIdUsingGETRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreOffenderApi
     */
    public getNsiForOffenderByCrnAndConvictionIdUsingGET(requestParameters: CoreOffenderApiGetNsiForOffenderByCrnAndConvictionIdUsingGETRequest, options?: any) {
        return CoreOffenderApiFp(this.configuration).getNsiForOffenderByCrnAndConvictionIdUsingGET(requestParameters.convictionId, requestParameters.crn, requestParameters.nsiCodes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return all the NSIs for the CRN, active convictions only, filtering by NSI codes
     * @param {CoreOffenderApiGetNsisForOffenderByCrnAndActiveConvictionsUsingGETRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreOffenderApi
     */
    public getNsisForOffenderByCrnAndActiveConvictionsUsingGET(requestParameters: CoreOffenderApiGetNsisForOffenderByCrnAndActiveConvictionsUsingGETRequest, options?: any) {
        return CoreOffenderApiFp(this.configuration).getNsisForOffenderByCrnAndActiveConvictionsUsingGET(requestParameters.crn, requestParameters.nsiCodes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the contact details for an offender
     * @param {CoreOffenderApiGetOffenderContactReportByNomsNumberUsingGETRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreOffenderApi
     */
    public getOffenderContactReportByNomsNumberUsingGET(requestParameters: CoreOffenderApiGetOffenderContactReportByNomsNumberUsingGETRequest, options?: any) {
        return CoreOffenderApiFp(this.configuration).getOffenderContactReportByNomsNumberUsingGET(requestParameters.contactTypes, requestParameters.from, requestParameters.nomsNumber, requestParameters.to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the convictions (AKA Delius Event) for an offender that contain RAR
     * @param {CoreOffenderApiGetOffenderConvictionsWithRarByCrnUsingGETRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreOffenderApi
     */
    public getOffenderConvictionsWithRarByCrnUsingGET(requestParameters: CoreOffenderApiGetOffenderConvictionsWithRarByCrnUsingGETRequest, options?: any) {
        return CoreOffenderApiFp(this.configuration).getOffenderConvictionsWithRarByCrnUsingGET(requestParameters.crn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the full offender detail for the given crn
     * @param {CoreOffenderApiGetOffenderDetailByCrnUsingGETRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreOffenderApi
     */
    public getOffenderDetailByCrnUsingGET(requestParameters: CoreOffenderApiGetOffenderDetailByCrnUsingGETRequest, options?: any) {
        return CoreOffenderApiFp(this.configuration).getOffenderDetailByCrnUsingGET(requestParameters.crn, requestParameters.authenticated, requestParameters.authorities0Authority, requestParameters.credentials, requestParameters.details, requestParameters.principal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the full offender detail for the given nomsNumber. If multiple offender found the active one will be returned
     * @param {CoreOffenderApiGetOffenderDetailByNomsNumberUsingGETRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreOffenderApi
     */
    public getOffenderDetailByNomsNumberUsingGET(requestParameters: CoreOffenderApiGetOffenderDetailByNomsNumberUsingGETRequest, options?: any) {
        return CoreOffenderApiFp(this.configuration).getOffenderDetailByNomsNumberUsingGET(requestParameters.nomsNumber, requestParameters.failOnDuplicate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the details for an offender. If multiple offenders found the active one wll be returned
     * @param {CoreOffenderApiGetOffenderDetailsUsingGETRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreOffenderApi
     */
    public getOffenderDetailsUsingGET(requestParameters: CoreOffenderApiGetOffenderDetailsUsingGETRequest, options?: any) {
        return CoreOffenderApiFp(this.configuration).getOffenderDetailsUsingGET(requestParameters.nomsNumber, requestParameters.failOnDuplicate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * requires ROLE_COMMUNITY
     * @summary Return the identifiers for an offender using the crn
     * @param {CoreOffenderApiGetOffenderIdentifiersByCrnUsingGETRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreOffenderApi
     */
    public getOffenderIdentifiersByCrnUsingGET(requestParameters: CoreOffenderApiGetOffenderIdentifiersByCrnUsingGETRequest, options?: any) {
        return CoreOffenderApiFp(this.configuration).getOffenderIdentifiersByCrnUsingGET(requestParameters.crn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * requires ROLE_COMMUNITY
     * @summary Return the identifiers for an offender using NOMS number
     * @param {CoreOffenderApiGetOffenderIdentifiersByNomsNumberUsingGETRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreOffenderApi
     */
    public getOffenderIdentifiersByNomsNumberUsingGET(requestParameters: CoreOffenderApiGetOffenderIdentifiersByNomsNumberUsingGETRequest, options?: any) {
        return CoreOffenderApiFp(this.configuration).getOffenderIdentifiersByNomsNumberUsingGET(requestParameters.nomsNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * requires ROLE_COMMUNITY
     * @summary Return the identifiers for an offender using offenderId
     * @param {CoreOffenderApiGetOffenderIdentifiersByOffenderIdUsingGETRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreOffenderApi
     */
    public getOffenderIdentifiersByOffenderIdUsingGET(requestParameters: CoreOffenderApiGetOffenderIdentifiersByOffenderIdUsingGETRequest, options?: any) {
        return CoreOffenderApiFp(this.configuration).getOffenderIdentifiersByOffenderIdUsingGET(requestParameters.offenderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return pageable list of all offender identifiers that match the supplied filter
     * @param {CoreOffenderApiGetOffenderIdsUsingGETRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreOffenderApi
     */
    public getOffenderIdsUsingGET(requestParameters: CoreOffenderApiGetOffenderIdsUsingGETRequest = {}, options?: any) {
        return CoreOffenderApiFp(this.configuration).getOffenderIdsUsingGET(requestParameters.activeDate, requestParameters.includeActiveOnly, requestParameters.includeDeleted, requestParameters.offset, requestParameters.page, requestParameters.paged, requestParameters.pageNumber, requestParameters.pageSize, requestParameters.size, requestParameters.sort, requestParameters.sortSorted, requestParameters.sortUnsorted, requestParameters.unpaged, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the probation status for the given crn
     * @param {CoreOffenderApiGetOffenderProbationStatusByCrnUsingGETRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreOffenderApi
     */
    public getOffenderProbationStatusByCrnUsingGET(requestParameters: CoreOffenderApiGetOffenderProbationStatusByCrnUsingGETRequest, options?: any) {
        return CoreOffenderApiFp(this.configuration).getOffenderProbationStatusByCrnUsingGET(requestParameters.crn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the offender summary for the given crn
     * @param {CoreOffenderApiGetOffenderSummaryByCrnUsingGETRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreOffenderApi
     */
    public getOffenderSummaryByCrnUsingGET(requestParameters: CoreOffenderApiGetOffenderSummaryByCrnUsingGETRequest, options?: any) {
        return CoreOffenderApiFp(this.configuration).getOffenderSummaryByCrnUsingGET(requestParameters.crn, requestParameters.authenticated, requestParameters.authorities0Authority, requestParameters.credentials, requestParameters.details, requestParameters.principal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts a NOMIS offender nomsNumber in the format A9999AA
     * @summary Return the responsible officer (RO) for an offender
     * @param {CoreOffenderApiGetResponsibleOfficersForOffenderUsingGETRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreOffenderApi
     */
    public getResponsibleOfficersForOffenderUsingGET(requestParameters: CoreOffenderApiGetResponsibleOfficersForOffenderUsingGETRequest, options?: any) {
        return CoreOffenderApiFp(this.configuration).getResponsibleOfficersForOffenderUsingGET(requestParameters.nomsNumber, requestParameters.current, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return sentence and custodial status information by crn, convictionId.
     * @param {CoreOffenderApiGetSentenceStatusByConvictionIdUsingGETRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreOffenderApi
     */
    public getSentenceStatusByConvictionIdUsingGET(requestParameters: CoreOffenderApiGetSentenceStatusByConvictionIdUsingGETRequest, options?: any) {
        return CoreOffenderApiFp(this.configuration).getSentenceStatusByConvictionIdUsingGET(requestParameters.convictionId, requestParameters.crn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requires role ROLE_COMMUNITY_CUSTODY_UPDATE
     * @summary Sets the responsible officer for an offender to either the current prison offender manager to community offender manager. This will allow the responsible officer to be set to an unallocated offender manager
     * @param {CoreOffenderApiSwitchResponsibleOfficerUsingPUTRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreOffenderApi
     */
    public switchResponsibleOfficerUsingPUT(requestParameters: CoreOffenderApiSwitchResponsibleOfficerUsingPUTRequest, options?: any) {
        return CoreOffenderApiFp(this.configuration).switchResponsibleOfficerUsingPUT(requestParameters.nomsNumber, requestParameters.responsibleOfficerSwitch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update offender tier. Requires ROLE_MANAGEMENT_TIER_UPDATE
     * @param {CoreOffenderApiUpdateTierUsingPOSTRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreOffenderApi
     */
    public updateTierUsingPOST(requestParameters: CoreOffenderApiUpdateTierUsingPOSTRequest, options?: any) {
        return CoreOffenderApiFp(this.configuration).updateTierUsingPOST(requestParameters.crn, requestParameters.tier, options).then((request) => request(this.axios, this.basePath));
    }
}
